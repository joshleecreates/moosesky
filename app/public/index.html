<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bluesky Word Trends</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #0a0a0f;
      color: #e1e1e6;
      min-height: 100vh;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 30px;
      padding-bottom: 20px;
      border-bottom: 1px solid #2a2a3a;
    }

    h1 {
      font-size: 1.8rem;
      font-weight: 600;
      background: linear-gradient(135deg, #0085ff, #00d4ff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .stats-bar {
      display: flex;
      gap: 20px;
      font-size: 0.85rem;
      color: #8888a0;
    }

    .stat {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .stat-value {
      color: #00d4ff;
      font-weight: 600;
    }

    .main-grid {
      display: grid;
      grid-template-columns: 1fr 300px;
      gap: 20px;
    }

    .card {
      background: #12121a;
      border: 1px solid #2a2a3a;
      border-radius: 12px;
      padding: 20px;
    }

    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }

    .card-title {
      font-size: 1rem;
      font-weight: 600;
      color: #ffffff;
    }

    .search-form {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
    }

    input[type="text"] {
      flex: 1;
      padding: 12px 16px;
      background: #1a1a25;
      border: 1px solid #2a2a3a;
      border-radius: 8px;
      color: #e1e1e6;
      font-size: 0.95rem;
      outline: none;
      transition: border-color 0.2s;
    }

    input[type="text"]:focus {
      border-color: #0085ff;
    }

    input[type="text"]::placeholder {
      color: #5a5a70;
    }

    button {
      padding: 12px 24px;
      background: linear-gradient(135deg, #0085ff, #0066cc);
      border: none;
      border-radius: 8px;
      color: white;
      font-size: 0.95rem;
      font-weight: 500;
      cursor: pointer;
      transition: transform 0.1s, opacity 0.2s;
    }

    button:hover {
      opacity: 0.9;
    }

    button:active {
      transform: scale(0.98);
    }

    button.secondary {
      background: #2a2a3a;
    }

    .time-controls {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .time-btn {
      padding: 8px 14px;
      font-size: 0.8rem;
      background: #1a1a25;
      border: 1px solid #2a2a3a;
      border-radius: 6px;
      cursor: pointer;
      color: #8888a0;
      transition: all 0.2s;
    }

    .time-btn:hover, .time-btn.active {
      background: #0085ff;
      border-color: #0085ff;
      color: white;
    }

    #chart {
      width: 100%;
      height: 400px;
      position: relative;
    }

    #chart svg {
      width: 100%;
      height: 100%;
    }

    .axis text {
      fill: #8888a0;
      font-size: 11px;
    }

    .axis line, .axis path {
      stroke: #2a2a3a;
    }

    .grid line {
      stroke: #1a1a25;
    }

    .line {
      fill: none;
      stroke-width: 2;
    }

    .dot {
      stroke-width: 2;
    }

    .tooltip {
      position: absolute;
      background: #1a1a25;
      border: 1px solid #2a2a3a;
      border-radius: 8px;
      padding: 10px 14px;
      font-size: 0.85rem;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 100;
    }

    .tooltip-word {
      font-weight: 600;
      color: #00d4ff;
    }

    .tooltip-count {
      color: #e1e1e6;
    }

    .tooltip-time {
      color: #8888a0;
      font-size: 0.75rem;
    }

    .trending-list {
      list-style: none;
    }

    .trending-item {
      display: flex;
      align-items: center;
      padding: 12px 0;
      border-bottom: 1px solid #1a1a25;
      cursor: pointer;
      transition: background 0.2s;
    }

    .trending-item:hover {
      background: #1a1a25;
      margin: 0 -20px;
      padding: 12px 20px;
    }

    .trending-item:last-child {
      border-bottom: none;
    }

    .trending-rank {
      width: 28px;
      height: 28px;
      background: #1a1a25;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.75rem;
      font-weight: 600;
      margin-right: 12px;
      color: #8888a0;
    }

    .trending-rank.top3 {
      background: linear-gradient(135deg, #0085ff, #0066cc);
      color: white;
    }

    .trending-word {
      flex: 1;
      font-weight: 500;
    }

    .trending-count {
      color: #00d4ff;
      font-weight: 600;
      font-size: 0.9rem;
    }

    .compare-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 16px;
    }

    .compare-tag {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      background: #1a1a25;
      border-radius: 20px;
      font-size: 0.85rem;
    }

    .compare-tag-color {
      width: 10px;
      height: 10px;
      border-radius: 50%;
    }

    .compare-tag-remove {
      cursor: pointer;
      color: #8888a0;
      font-size: 1rem;
      line-height: 1;
    }

    .compare-tag-remove:hover {
      color: #ff4444;
    }

    .no-data {
      text-align: center;
      padding: 60px 20px;
      color: #5a5a70;
    }

    .loading {
      text-align: center;
      padding: 60px 20px;
      color: #8888a0;
    }

    .legend {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      margin-top: 16px;
      justify-content: center;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 0.85rem;
    }

    .legend-color {
      width: 12px;
      height: 3px;
      border-radius: 2px;
    }

    @media (max-width: 900px) {
      .main-grid {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Bluesky Word Trends</h1>
      <div class="stats-bar">
        <div class="stat">
          <span>Unique words:</span>
          <span class="stat-value" id="stat-words">-</span>
        </div>
        <div class="stat">
          <span>Total occurrences:</span>
          <span class="stat-value" id="stat-occurrences">-</span>
        </div>
        <div class="stat">
          <span>Data range:</span>
          <span class="stat-value" id="stat-range">-</span>
        </div>
      </div>
    </header>

    <div class="main-grid">
      <div class="main-content">
        <div class="card">
          <div class="card-header">
            <span class="card-title">Word Trend Chart</span>
            <div class="time-controls">
              <button class="time-btn" data-minutes="5">5m</button>
              <button class="time-btn" data-minutes="15">15m</button>
              <button class="time-btn active" data-minutes="60">1h</button>
              <button class="time-btn" data-minutes="360">6h</button>
              <button class="time-btn" data-minutes="1440">24h</button>
            </div>
          </div>
          <form class="search-form" id="search-form">
            <input type="text" id="word-input" placeholder="Enter word to track (e.g., bluesky, twitter, news)">
            <button type="submit">Search</button>
            <button type="button" class="secondary" id="add-compare">+ Compare</button>
          </form>
          <div class="compare-tags" id="compare-tags"></div>
          <div id="chart">
            <div class="no-data">Enter a word to see its trend over time</div>
          </div>
          <div class="legend" id="legend"></div>
        </div>
      </div>

      <aside>
        <div class="card">
          <div class="card-header">
            <span class="card-title">Top Trending</span>
            <button class="time-btn" id="refresh-trending">Refresh</button>
          </div>
          <ul class="trending-list" id="trending-list">
            <li class="loading">Loading...</li>
          </ul>
        </div>
      </aside>
    </div>
  </div>

  <div class="tooltip" id="tooltip"></div>

  <script>
    const API_BASE = '/trends';
    const COLORS = ['#00d4ff', '#ff6b6b', '#4ecdc4', '#ffe66d', '#95e1d3', '#f38181', '#aa96da', '#fcbad3', '#a8d8ea', '#ffd3b5'];

    let currentWords = [];
    let timeRangeMinutes = 60;
    let chartData = {};

    // Format numbers with K/M suffixes
    function formatNumber(num) {
      const n = parseInt(num) || 0;
      if (n >= 1000000) return (n / 1000000).toFixed(1) + 'M';
      if (n >= 1000) return (n / 1000).toFixed(1) + 'K';
      return n.toString();
    }

    // Format time for display (local timezone)
    function formatTime(date) {
      if (!(date instanceof Date)) date = new Date(date);
      const hours = date.getHours().toString().padStart(2, '0');
      const mins = date.getMinutes().toString().padStart(2, '0');
      const secs = date.getSeconds().toString().padStart(2, '0');
      return `${hours}:${mins}:${secs}`;
    }

    // Format date+time for display (local timezone)
    function formatDateTime(date) {
      if (!(date instanceof Date)) date = new Date(date);
      const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
      const month = months[date.getMonth()];
      const day = date.getDate();
      const hours = date.getHours().toString().padStart(2, '0');
      const mins = date.getMinutes().toString().padStart(2, '0');
      return `${month} ${day}, ${hours}:${mins}`;
    }

    // Load stats
    async function loadStats() {
      try {
        const res = await fetch(`${API_BASE}/stats`);
        const data = await res.json();
        if (data.success) {
          document.getElementById('stat-words').textContent = formatNumber(data.uniqueWords || 0);
          document.getElementById('stat-occurrences').textContent = formatNumber(data.totalOccurrences || 0);
          if (data.earliestData && data.latestData) {
            const earliest = new Date(data.earliestData).toLocaleDateString();
            const latest = new Date(data.latestData).toLocaleDateString();
            document.getElementById('stat-range').textContent = earliest === latest ? earliest : `${earliest} - ${latest}`;
          }
        }
      } catch (err) {
        console.error('Failed to load stats:', err);
      }
    }

    // Load trending words
    async function loadTrending() {
      const list = document.getElementById('trending-list');
      list.innerHTML = '<li class="loading">Loading...</li>';

      try {
        const res = await fetch(`${API_BASE}/top?minutes=${timeRangeMinutes}&limit=15`);
        const data = await res.json();

        if (data.success && data.data.length > 0) {
          list.innerHTML = data.data.map((item, i) => `
            <li class="trending-item" data-word="${item.word}">
              <span class="trending-rank ${i < 3 ? 'top3' : ''}">${i + 1}</span>
              <span class="trending-word">${item.word}</span>
              <span class="trending-count">${formatNumber(item.total)}</span>
            </li>
          `).join('');

          // Add click handlers
          list.querySelectorAll('.trending-item').forEach(item => {
            item.addEventListener('click', () => {
              const word = item.dataset.word;
              document.getElementById('word-input').value = word;
              searchWord(word);
            });
          });
        } else {
          list.innerHTML = '<li class="no-data">No trending data yet</li>';
        }
      } catch (err) {
        console.error('Failed to load trending:', err);
        list.innerHTML = '<li class="no-data">Failed to load trending words</li>';
      }
    }

    // Search for a word
    async function searchWord(word) {
      if (!word) return;

      word = word.toLowerCase().trim();
      if (!currentWords.includes(word)) {
        currentWords = [word];
        chartData = {};
      }

      await loadWordData(word);
      renderChart();
      updateCompareTags();
    }

    // Add word for comparison
    async function addCompareWord(word) {
      if (!word) return;

      word = word.toLowerCase().trim();
      if (currentWords.includes(word)) {
        console.log(`Word "${word}" already in comparison`);
        return;
      }
      if (currentWords.length >= 5) {
        alert('Maximum 5 words for comparison');
        return;
      }

      console.log(`Adding "${word}" to comparison. Current words:`, currentWords);
      currentWords.push(word);
      await loadWordData(word);
      console.log(`Chart data after loading "${word}":`, chartData);
      renderChart();
      updateCompareTags();
    }

    // Remove word from comparison
    function removeWord(word) {
      currentWords = currentWords.filter(w => w !== word);
      delete chartData[word];
      renderChart();
      updateCompareTags();
    }

    // Load data for a word
    async function loadWordData(word) {
      const to = new Date();
      const from = new Date(to.getTime() - timeRangeMinutes * 60 * 1000);

      try {
        const url = `${API_BASE}/search?word=${encodeURIComponent(word)}&from=${from.toISOString()}&to=${to.toISOString()}`;
        console.log(`Fetching: ${url}`);
        const res = await fetch(url);
        const data = await res.json();
        console.log(`Response for "${word}":`, data);

        if (data.success) {
          // Parse and aggregate data by timestamp
          const aggregated = new Map();
          data.data.forEach(d => {
            // Add 'Z' to tell JS this is UTC, then convert to local
            const utcString = d.interval.replace(' ', 'T') + 'Z';
            const ts = new Date(utcString).getTime();
            const count = parseInt(d.count) || 0;
            aggregated.set(ts, (aggregated.get(ts) || 0) + count);
          });

          // Convert to array and sort by time
          chartData[word] = Array.from(aggregated.entries())
            .map(([ts, count]) => ({ interval: new Date(ts), count }))
            .sort((a, b) => a.interval - b.interval);
        }
      } catch (err) {
        console.error(`Failed to load data for ${word}:`, err);
      }
    }

    // Update compare tags
    function updateCompareTags() {
      const container = document.getElementById('compare-tags');
      if (currentWords.length <= 1) {
        container.innerHTML = '';
        return;
      }

      container.innerHTML = currentWords.map((word, i) => `
        <span class="compare-tag">
          <span class="compare-tag-color" style="background: ${COLORS[i % COLORS.length]}"></span>
          ${word}
          <span class="compare-tag-remove" data-word="${word}">&times;</span>
        </span>
      `).join('');

      container.querySelectorAll('.compare-tag-remove').forEach(btn => {
        btn.addEventListener('click', () => removeWord(btn.dataset.word));
      });
    }

    // Render chart
    function renderChart() {
      const container = document.getElementById('chart');
      const legendContainer = document.getElementById('legend');

      if (currentWords.length === 0 || Object.keys(chartData).length === 0) {
        container.innerHTML = '<div class="no-data">Enter a word to see its trend over time</div>';
        legendContainer.innerHTML = '';
        return;
      }

      // Check if any data exists
      const hasData = Object.values(chartData).some(data => data.length > 0);
      if (!hasData) {
        container.innerHTML = '<div class="no-data">No data found for the selected word(s)</div>';
        legendContainer.innerHTML = '';
        return;
      }

      container.innerHTML = '';

      const margin = { top: 20, right: 30, bottom: 40, left: 50 };
      const width = container.clientWidth - margin.left - margin.right;
      const height = 400 - margin.top - margin.bottom;

      const svg = d3.select('#chart')
        .append('svg')
        .attr('viewBox', `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`)
        .append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);

      // Get all data points for scales
      const allData = Object.values(chartData).flat();

      // X scale (time)
      const xExtent = d3.extent(allData, d => d.interval);
      const x = d3.scaleTime()
        .domain(xExtent)
        .range([0, width]);

      // Y scale (count)
      const yMax = d3.max(allData, d => d.count) || 1;
      const y = d3.scaleLinear()
        .domain([0, yMax * 1.1])
        .range([height, 0]);

      // Grid lines
      svg.append('g')
        .attr('class', 'grid')
        .call(d3.axisLeft(y)
          .tickSize(-width)
          .tickFormat('')
        );

      // X axis
      svg.append('g')
        .attr('class', 'axis')
        .attr('transform', `translate(0,${height})`)
        .call(d3.axisBottom(x)
          .ticks(6)
          .tickFormat(d => formatTime(d))
        );

      // Y axis
      svg.append('g')
        .attr('class', 'axis')
        .call(d3.axisLeft(y)
          .ticks(5)
          .tickFormat(d => formatNumber(d))
        );

      // Line generator
      const line = d3.line()
        .x(d => x(d.interval))
        .y(d => y(d.count))
        .curve(d3.curveMonotoneX);

      // Tooltip
      const tooltip = d3.select('#tooltip');

      // Draw lines for each word
      currentWords.forEach((word, i) => {
        const data = chartData[word] || [];
        if (data.length === 0) return;

        const color = COLORS[i % COLORS.length];

        // Line
        svg.append('path')
          .datum(data)
          .attr('class', 'line')
          .attr('stroke', color)
          .attr('d', line);

        // Only show dots if there aren't too many data points
        const showDots = data.length <= 100;
        const dotRadius = data.length > 50 ? 2 : 4;

        if (showDots) {
          svg.selectAll(`.dot-${i}`)
            .data(data)
            .enter()
            .append('circle')
            .attr('class', `dot dot-${i}`)
            .attr('cx', d => x(d.interval))
            .attr('cy', d => y(d.count))
            .attr('r', dotRadius)
            .attr('fill', '#0a0a0f')
            .attr('stroke', color)
            .on('mouseover', (event, d) => {
              tooltip
                .style('opacity', 1)
                .html(`
                  <div class="tooltip-word">${word}</div>
                  <div class="tooltip-count">${formatNumber(d.count)} occurrences</div>
                  <div class="tooltip-time">${formatDateTime(d.interval)}</div>
                `)
                .style('left', (event.pageX + 10) + 'px')
                .style('top', (event.pageY - 10) + 'px');
            })
            .on('mouseout', () => {
              tooltip.style('opacity', 0);
            });
        }
      });

      // Update legend
      if (currentWords.length > 1) {
        legendContainer.innerHTML = currentWords.map((word, i) => `
          <div class="legend-item">
            <span class="legend-color" style="background: ${COLORS[i % COLORS.length]}"></span>
            ${word}
          </div>
        `).join('');
      } else {
        legendContainer.innerHTML = '';
      }
    }

    // Event listeners
    document.getElementById('search-form').addEventListener('submit', (e) => {
      e.preventDefault();
      const input = document.getElementById('word-input');
      const word = input.value;
      searchWord(word);
      input.value = ''; // Clear for next word
      input.placeholder = `Comparing: ${word} - enter another word`;
    });

    document.getElementById('add-compare').addEventListener('click', async () => {
      const word = document.getElementById('word-input').value;
      if (!word.trim()) {
        alert('Enter a word first');
        return;
      }
      await addCompareWord(word);
      document.getElementById('word-input').value = '';
    });

    document.querySelectorAll('.time-btn[data-minutes]').forEach(btn => {
      btn.addEventListener('click', async () => {
        document.querySelectorAll('.time-btn[data-minutes]').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        timeRangeMinutes = parseInt(btn.dataset.minutes);

        // Reload all word data
        for (const word of currentWords) {
          await loadWordData(word);
        }
        renderChart();
        loadTrending();
      });
    });

    document.getElementById('refresh-trending').addEventListener('click', loadTrending);

    // Handle window resize
    window.addEventListener('resize', renderChart);

    // Initial load
    loadStats();
    loadTrending();

    // Auto-refresh trending every 30 seconds
    setInterval(loadTrending, 30000);
    setInterval(loadStats, 60000);
  </script>
</body>
</html>
